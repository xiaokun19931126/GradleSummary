// Top-level build file where you can add configuration options common to all sub-projects/modules.

//扩展属性,当前工程可以直接使用以下属性,其他子工程调用rootProject.ext.project
ext {
    projectName = "gradle for android"
    codeName = "groovy"
    compileVersion = 29
    buildToolsVersion = "29.0.2"
    desc = "这是扩展属性"
    local = "Hello form build.gradle"
}

/**
 * Configures the build script classpath for this project.
 * 为这个工程配置build脚本类路径
 */
buildscript {
    ext.kotlin_version = '1.3.41'
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.5.0'
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

/**
 * Configures this project and each of its sub-projects.
 * 为所有工程配置包括自身和子工程
 */
allprojects {
    repositories {
        google()
        jcenter()
    }
}

/**
 * Delete task类型: Deletes files or directories.
 */
task clean(type: Delete) {
    println rootProject.buildDir
    delete rootProject.buildDir
}

/**
 * 自定义task
 */
task test_gradle {
    doLast {
        println 'this is gradle task'
        println "project:${projectName}"
        println "codeName:${codeName}"
    }
}

task printProperties {
    doLast {
        println local
        println propertiesFile
        if (project.hasProperty("cmd")) {
            println cmd
        }
    }
}

task test1 {
    doLast {
        getPlugins().each {
            println "插件名称:${it.class.name}"
        }
    }
}

task make {
    doLast {
        //assemble
        println '依赖assembleDebug'
        println "根路径：${getRootDir().absolutePath}"
        getAllprojects().each {
            println "project:$it"
        }
    }
}

task('make1') {
    //依赖子工程中的task
    //dependsOn ':app:assembleDebug'
    doLast {
        def app = findProject('app')
        println "appName:$app"
        getSubprojects().each {
            println "子工程：$it"
            println "子工程path:${it.getPath()}"
            it.getTasks().each {
                //println "子工程任务:${it.toString()}"
                if (it.toString().contains(':app:assembleDebug')) {
                    println "子工程任务:$it"
                }
            }
        }
        getTasks().each {
            println "任务:$it"
        }
        println "编译"
    }
}

task('launchApp') {
    doLast {
        def cmd = "adb shell am start com.example.gradletest/.MainActivity"
        try {
            exec {
                executable 'cmd'
                args '/c', cmd
            }
        } catch (Exception e) {
            println "error:${e.getMessage()}"
        }
        println 'app已启动成功!'
    }
}


//这是练习gradle groovy语法的demo
//首先需要下载gradle，我们Android开发者一定是有下载gradle版本的，给gradle设置环境变量
//然后任意位置新建build.gradle文件，打开cmd cd到当前文件目录下
//执行gradle相关命令即可

//groovy语法跟java很类似，以下是常用的一些区别

//字符串
//groovy语法，字符串可以用'' "" ，区别是单引号就是单纯的字符串，双引号里面可以有变量运算，利用${a+b}这样

//变量
//groovy中，定义变量使用def，不需要显示指定变量类型，每行代码后不需要分号，当然加分号也不会报错

//方法
//groovy中，定义方法也使用def，不需要指定返回值，也可以不适用return关键字

//闭包
//groovy中，有闭包概念 定义方法为 a ={int a -> println a} ，大括号+参数+箭头符号+输出语句
//其中参数可以不用显示指定类型，如果没有显示指定参数，默认会给一个it参数，不传递默认为null

//集合list和map


task hello

hello.doFirst {
    println 'hello first do it'
    hello1()
}


task world

world.doLast {
    println 'last do it '
}

task test {
    description "你好"
    group '测试demo'
    doLast {
        println '欢迎你'
    }
}

println '\n开始字符串测试:'
def a = 1
def b = 'hello world'
def c = 1;

def d = "a=${a},b=$b"

println d

task test2 {
    hello3(d)
}

def hello1() {
    println('hello world')
    return 1
}


int hello2(msg) {
    println(msg)

    return 1
}

int hello3(msg) {
    println msg
    return 1
    println 'done'
}

println '\n开始闭包测试:'
//闭包
def closure = { int i, int s ->
    println "求和:${i + s}"
}

def closure4 = { int i, int i2 ->
    println "相乘:${i * i2}"
}

def closure1 = { i, s ->
    println "i, 我是闭包$s"
}

def closure3 = {
    println "$d, 我是闭包3"
}

//闭包如果不传参数，会默认一个隐藏参数，不传递默认为null
def closure5 = {
    println "$it,我才是最后的胜利者"
}


println closure(100, 39)
println closure4(8, 8)
println closure5('chousb')
println closure5()


task test3 {
    closure3()
    closure1(100, '哈皮')
}

//groovy list
println '\n开始list测试:'
def test4 = [100, 'hello', true]
println test4[0]
println test4[1]
test4[1] = 'world'
println test4[1]
test4 << 200
println test4.size
println test4[3]
test4 << 500
println test4[1..4]//访问第二个到第四个元素
println test4[-1]//访问倒数第一个元素

println '\n遍历集合:'
test4.each {
    println it
}

//groovy map
println '\n开始map测试:'
def map1 = ['width': 1080, 'height': 720]
println map1.getClass().name
println '获取map中的值，两种方式：1.使用中括号[]；2.使用.key方式'
println map1['width']
println map1.height
println "width:${map1['width']}"
println "height:${map1.height}"
println 'map循环遍历:'
map1.each {
    println "Key:${it.key},Value:${it.value}"
}

//groovy 方法特点：
println '\n开始groovy方法测试:'

//1.调用方法时，括号是可以省略的
method1(1, 2)
method1 1, 2
println "获取较大值:${method2(10, 4)}"

def method1(int a, int b) {
    println "求和：${a + b}"
}

//2.retrun是可以不用写的，但是建议加上
def method2(int a, int b) {
    if (a > b) {
        a
    } else {
        b
    }
}

//3.代码块是可以作为参数传递的，其实就是闭包，由一段被大括号包围的代码
//以list遍历为例子来看闭包的演化
//a.首先将{代码块}作为参数传入each方法中
test4.each({ println it })
//b.groovy规定，如果方法的最后一个参数是闭包，可以放到方法外面
test4.each() {
    println it
}
//c.然后方法可以省略
test4.each {
    println it
}

//groovy javabean
println '\n开始groovy javabean测试:'

class Person {
    private String name

    public int getAge() {
        12
    }
}

def p = new Person()
println "名字是：${p.name}"
p.name = '李四'
println "名字是：${p.name}"

//其次，如果设置了setter/getter方法，也可以直接.属性
println "${p.name}的年龄是:${p.age}"




















