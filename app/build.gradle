apply plugin: 'com.android.application'

apply plugin: 'kotlin-android'

apply plugin: 'kotlin-android-extensions'

apply plugin: CustomPlugin

android {
    println '测试一下这里'
    compileSdkVersion 29
    buildToolsVersion "29.0.2"

    /**
     * 默认配置
     */
    defaultConfig {
        applicationId "com.example.gradletest"
        minSdkVersion 15
        targetSdkVersion 29
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        //apk只保留 xxhdpi 资源
        resConfigs "xxhdpi"
    }

    /**
     * 签名配置
     */
    signingConfigs {
        release {
            storeFile file('E:\\android\\ProjectSpaces\\SantiDemo\\app\\santee_demo.jks')
            storePassword '123456'
            keyPassword '123456'
            keyAlias = 'rongshi'
        }
        staging {
            storeFile file('E:\\android\\ProjectSpaces\\SantiDemo\\app\\santee_demo.jks')
            storePassword '123456'
            keyAlias = 'rongshi'
            keyPassword '123456'
        }
    }

    /**
     * buildTypes和product flavor的结合被称之为构建variant
     *
     * product flavor 极大简化了基于相同代码构建多个版本的应用的进程
     */
    //flavor 维度列表
    flavorDimensions 'api', 'version'
    productFlavors {
        single {
            // 指定这个 flavor 为 version
            dimension 'version'
        }
        full {
            // 指定这个 flavor 为 version
            dimension 'version'
        }
        minApi24 {
            // 指定这个 flavor 为 api
            dimension 'api'
            minSdkVersion '24'
            versionNameSuffix "-minApi24"
        }
        minApi21 {
            dimension "api"
            minSdkVersion '21'
            versionNameSuffix "-minApi21"
        }
    }

    buildTypes {
        staging {
            staging.initWith(buildTypes.debug)
            //minifyEnabled false
            //proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.staging
            applicationIdSuffix ".staging"
            versionNameSuffix "-staging"
            //使用debug type中相似的配置
            buildConfigField "String", "APP_URL", "\"http://staging.example.com/api/\""
            buildConfigField("boolean", "LOG_HTTP_CALLS", "true")
            resValue "string", "app_name", "GradleTestStaging"
            resValue("color", "text_color", "#0000ff")
        }

        debug {
            signingConfig signingConfigs.release
            applicationIdSuffix ".debug"
            versionNameSuffix "-debug"
            //Whether removal of unused java code is enabled.
            //是否删除未启动的java代码
            minifyEnabled false
            //Adds a new field to the generated BuildConfig class.
            //给自动生成的BuildConfig类添加新属性
            //groovy语法中,方法可以省略括号不写,所以下面两种调用方式都正确
            buildConfigField "String", "APP_URL", "\"http://test.example.com/api/\""
            buildConfigField("boolean", "LOG_HTTP_CALLS", "false")
            //This is equivalent to specifying a resource in res/values.
            //这个跟在res/values下指定值的作用是一样的
            resValue "string", "app_name", "GradleTestDebug"
            resValue("color", "text_color", "#00ff00")
        }
        release {
            release.initWith(buildTypes.debug)
            //minifyEnabled false
            //proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
            applicationIdSuffix ".release"
            versionNameSuffix "-release"
            buildConfigField "String", "APP_URL", "\"http://example.com/api/\""
            buildConfigField("boolean", "LOG_HTTP_CALLS", "true")
            resValue "string", "app_name", "GradleTestRelease"
            resValue("color", "text_color", "#ff0000")
        }
    }

    //hook到Android插件的方式之一是操控构建variant
    //遍历应用构建的所有 variant
    //如果想对库构建variant,则使用android.libraryVariants
    //便利方法没有使用each而是使用all
    //这是因为each方法会在构建variant,被Android插件创建之前的评测阶段被触发,
    //而all方法会在每次添加新项目到集合时被触发
    //经测试 each 和 all 方法并没有区别
    //该hook可以用来修改保存之前的APK名称,并为文件名添加版本号
    //android.applicationVariants.each { variant ->
    //    println "变体variant:$variant"
    //    variant.outputs.each {
    //        println "it是什么:$it"
    //        println "apk名称：${outputFileName}"
    //    }
    //}
    android.applicationVariants.all { variant ->
        println "变体variant:$variant"
        variant.outputs.all {
            println "it是什么:$it"
            println "apk名称：${outputFileName}"
        }
    }

    //源集
    sourceSets {

    }
}

dependencies {
    //android.applicationVariants.all {
    //    println "test variant,$it"
    //    println "appId:${it.generateBuildConfig.appPackageName}"
    //    println "variant:${it.variantData}"
    //    println "scope:${it.variantData.scope}"
    //}
    println '什么时候执行'
    println 'implementation 表示为所有 buildType 依赖,如果单独为 staging 模块,那么需要 stagingImplementation 起头'
    // stagingImplementation 'androidx.appcompat:appcompat:1.1.0'
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
    implementation 'androidx.appcompat:appcompat:1.1.0'
    implementation 'androidx.core:core-ktx:1.1.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test:runner:1.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.1'
}

def getInfo() {
    def extension = project.extensions.getByName("android")
    println "buildToolsVersion:${extension.buildToolsVersion}"
    println "compileSdkVersion:${extension.getCompileSdkVersion()}"
    println "applicationId:${extension.defaultConfig.applicationId}"
    println "minSdkVersion:${extension.defaultConfig.minSdkVersion}"
    println "targetSdkVersion:${extension.defaultConfig.targetSdkVersion}"
    println "versionCode:${extension.defaultConfig.versionCode}"
    println "versionName:${extension.defaultConfig.versionName}"
}

task test1 {
    getInfo()
    getPlugins().each {
        println "插件名称:${it.class.name}"
    }
}

//创建一个简单的自定义插件
class CustomPlugin implements Plugin<Project> {

    @Override
    void apply(Project target) {
        target.task("custom1") {
            println 'hello,world!输出自定义插件'
        }
    }
}